<!DOCTYPE html>
<html lang="en">
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Callan McGill">
    <meta name="author" content="Callan McGill">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Locally Nameless">
    <meta name="twitter:description" content="My first blog post using slick">
        <title>Locally Nameless</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
</head>
<body>
    <!DOCTYPE html>
    <header>
        <nav>
          
          <a id="beacon" href="/">
              <div id="home-text"> HOME </div>
          </a>
        </nav>
        <div class="right-sidebar">
            <a class="ext-link" href="https://github.com/boarders">
            <img src="/images/github-logo.png" alt="Github Profile"/>
        </a>

        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Locally Nameless
            </span>
            <br>

            <br>
            <span class="byline">by Callan McGill</span>
            <br>
            <span class="date">Oct 27, 2019</span>
            <br>
            <div class="metadata">
            </div>
            </div>
        </div>
    </div>
    <article class="post">
        <p>The untyped lambda calculus has a very simple grammar with just three term formers: <span class="math inline">\(\def\sp{\mspace{5mu}}\)</span></p>
<p><span class="math display">\[ \mathrm{term}
 \mathrel{\vcenter{\hbox{::}}{=}} v \sp
  | \sp \lambda \sp v \sp . \sp \mathrm{term} \sp
  | \sp \mathrm{term} \sp \mathrm{term} \sp
  \]</span></p>
<p>Or in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Lam</span> a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="dt">Var</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="dt">Lam</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Lam</span> a</span></code></pre></div>
<p>In order that this work as a theory of computation, we need some notion of evaluation and this is driven by <span class="math inline">\(\beta\)</span>-reduction. The standard jargon in lambda caluclus is to say that a <span class="math inline">\(\beta\)</span>-redex is any subterm of the form <span class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}\)</span>. On such a <span class="math inline">\(\beta\)</span>-redex we can then step via (capture-avoiding) substitution:</p>
<p><span class="math display">\[ (\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}
    \rightsquigarrow
   f\sp[x  \mathrel{\vcenter{\hbox{:}}{=}} \mathrm{arg}]
  \]</span></p>
<p>Formally we then extend this to a congruence relation on Lambda terms via rules of the form:</p>
<p><span class="math display">\[
  M \rightsquigarrow M&#39; \Rightarrow M N \rightsquigarrow M&#39; N
\]</span> <span class="math display">\[
  N \rightsquigarrow N&#39; \Rightarrow M N \rightsquigarrow M  N&#39;
  \]</span></p>
<p>Precisely how we choose to set up these rules to give a computational semantics to our language corresponds algorithmically to a choice of evaluation strategy. As such, this opens up myriad interesting questions related to order of evaluation and normal forms and so on. Instead we will largely bypass these considerations and concentrate on the more humdrum (but no less vital) matter of the practicalities of performing such capture-avoiding substitutions. The basic problem with too naive an approach is as follows:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp \lambda \sp y \sp . \sp  x) \sp \mathrm{y}
    \rightsquigarrow
   (\lambda \mathrm{y} \sp . \sp y)
  \]</span></p>
<p>Here we have substituted the <em>free</em> variable y into our lambda term and it has become <em>bound</em>. This is semantically incorrect: the names of free variables are meaningful because, in spirit, they refer to names we have defined elsewhere (that is, they can be looked up within a context, or, in other words, they are <em>open</em> for further substitution). Conversely, the names of bound variables are, computationally speaking, unimportant. In fact, it is usual to refer to the grammar we have introduced earlier as <em>pre-lambda terms</em> and to take lambda terms as referring to the equivalence classes under <span class="math inline">\(\alpha\)</span>-equivalence. This refers to the (equivalence) relation whereby two terms are equivalent if we can consistently rename the bound variables of one to obtain the other (here too we need to take care, <span class="math inline">\(\alpha\)</span>-renaming <span class="math inline">\(\mathrm{x}\)</span> to <span class="math inline">\(\mathrm{y}\)</span> in the above term would lead to a different sort of variable capture). Most accounts of <span class="math inline">\(\alpha\)</span>-equivalence are themselves intimiately tied up with the question of how to perform substitution (and locally nameless is no different in this respect).</p>
<p>In practice this means that in order to compute <span class="math inline">\((\lambda \mathrm{x} \sp . \sp \mathrm{f}) \sp \mathrm{arg}\)</span> we would first <span class="math inline">\(\alpha\)</span>-rename <span class="math inline">\(\mathrm{x}\)</span> to a variable that is neither already named within <span class="math inline">\(\mathrm{f}\)</span>, nor appears free within <span class="math inline">\(\mathrm{arg}\)</span>. Carrying out such a procedure by brute force is workable, but tends to be rather error-prone. A straightforward approach along these lines is described in <a href="http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html">this excellent post</a> by Lennart Augustsson.</p>
<p>There are a <a href="https://www.schoolofhaskell.com/user/edwardk/bound">whole host</a> of more sophisticated methods for dealing with the problem of capture-avoiding substitution. Perhaps one of the best known is to use De-Bruijn indices. The idea here is to replace all bound variables by a natural number. This indicates the variable’s distance from its binding site. All free variables are then represented by distinct natural numbers greater than the maximum depth of any binding site in the term. We then keep track of these variables within the environment under which computation is performed. For instance, the following is how one might translate a typical term into De-Bruijn indices:</p>
<p><span class="math display">\[ (\lambda \sp \mathrm{x} \sp . \sp \lambda \sp y \sp . \sp  x \sp z)
    \longrightarrow
   (\lambda \sp \lambda \sp . \sp 1 \sp 3 )
   \]</span> <span class="math display">\[
   [z \mapsto 3]
  \]</span></p>
<p>Here we keep both the translated lambda term but also the context for how to read free variables.</p>
<p>This approach offers two key advantages:</p>
<ul>
<li>Capture avoiding substitution becomes a matter of keeping binding distance arithmetic in check.</li>
<li>The De-Bruijn representation gives canonical representatives for <span class="math inline">\(\alpha\)</span>-equivalence classes, thus allowing us to test for <span class="math inline">\(\alpha\)</span>-equivalence via syntactic equality of terms.</li>
</ul>
<p>On the other hand, Bob Atkey has, rather aptly, referred to the ability to read terms written with DeBruijn indices as a “cylon detector”. What we gain in ease of implementation we give up in much worse readability.</p>
<p>Instead we turn to the hybrid approach in the paper <a href="http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf">I Am Not a Number – I am a Free Variable</a>. Let us keep free variables free and use De-Bruijn indices only for bound variables:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">-- Our variable type keeps the old free variables and uses</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co">--integers to represent bound variables.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Var</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">F</span> a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">B</span> <span class="dt">Int</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">-- Locally nameless terms will be the same lambda terms with</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co">-- variables now labelled either bound or free.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">LocallyNameless</span> a <span class="ot">=</span> <span class="dt">Lam</span> (<span class="dt">Var</span> a)</span></code></pre></div>
<p>Notice how, because we use the same lambda terms with this representation, we still have names at binders. This is useful as we can recover the named term we started out with, carrying along all such names as we perform work. Here is how we convert between the two representations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE LambdaCase          #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">[...]</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="ot">toLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>toLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map</span> a <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>      <span class="dt">Var</span> a  <span class="ot">-&gt;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>      <span class="co">-- we check if our variable has been bound elsewhere</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>        <span class="kw">case</span> a <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>          <span class="dt">Just</span> bv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> a)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        <span class="kw">let</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>       <span class="co">-- As we have gone under a binder we bump each variable</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>       <span class="co">-- by 1, inserting our newly bound variable at 0.</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>          env&#39; <span class="ot">=</span> insert n <span class="dv">0</span> (M.map (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>        <span class="kw">in</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>          <span class="dt">Lam</span> (<span class="dt">F</span> n) (go env&#39; e)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a><span class="ot">fromLocallyNameless ::</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>fromLocallyNameless <span class="ot">=</span> go <span class="fu">mempty</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Map</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a>    go env <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>      <span class="dt">Var</span> v <span class="ot">-&gt;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a>        <span class="kw">case</span> v <span class="kw">of</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a>          <span class="dt">F</span> a  <span class="ot">-&gt;</span> <span class="dt">Var</span> a</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true"></a>               <span class="co">-- we look up our bound variable with the name we collected from</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true"></a>               <span class="co">-- its binder</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="kw">case</span> bv <span class="ot">`lookup`</span> env <span class="kw">of</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true"></a>            <span class="dt">Just</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> name</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true"></a>            <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true"></a>              <span class="st">&quot;Found bound variable :&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv <span class="op">&lt;&gt;</span> <span class="st">&quot; without binder.&quot;</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true"></a>      <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go env l) (go env r)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true"></a>      <span class="dt">Lam</span> n e <span class="ot">-&gt;</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true"></a>        <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true"></a>       <span class="co">-- if our lambda term has a Bound variable at a binding site something</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true"></a>       <span class="co">-- has gone horribly wrong</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true"></a>          <span class="dt">B</span> bv <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Found unnamed variable at binding site&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> bv</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true"></a>          <span class="dt">F</span> v  <span class="ot">-&gt;</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true"></a>            <span class="kw">let</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true"></a>           <span class="co">-- We store the name of the binder in the environment</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true"></a>              env&#39; <span class="ot">=</span> insert <span class="dv">0</span> v (mapKeysMonotonic (<span class="op">+</span> <span class="dv">1</span>) env)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true"></a>            <span class="kw">in</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true"></a>              <span class="dt">Lam</span> v (go env&#39; e)</span></code></pre></div>
<p>Now let’s see that this works as expected (this is, for me, a worrying amount of bookeeping to leave to “Looks good!”). Let us use quickcheck to see that <strong>fromLocallyNameless</strong> is a left inverse to <strong>toLocallyNameless</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co">[...]</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="co">-- We use a somewhat unprincipled approach to generating arbitrary terms</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co">-- but for our purposes it will do the job.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Lam</span> a) <span class="kw">where</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  arbitrary <span class="ot">=</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="kw">do</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">10</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>      buildTerm i</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ot">      buildTerm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> (<span class="dt">Term</span> a)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>      buildTerm i</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">2</span>    <span class="ot">=</span> arbitrary <span class="op">&gt;&gt;=</span> <span class="fu">pure</span> <span class="op">.</span> <span class="dt">Var</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>        <span class="op">|</span> i <span class="op">&lt;=</span> <span class="dv">8</span>    <span class="ot">=</span> <span class="dt">Lam</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>       <span class="co">-- so that our terms don&#39;t explode we limit</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>       <span class="co">-- the amount of branching we allow</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">App</span> <span class="op">&lt;$&gt;</span> arbitrary <span class="op">&lt;*&gt;</span> arbitrary</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="co">-- fromLocalyNameless is a left inverse to toLocallyNameless.</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a><span class="ot">fromLocallyNamelessLeftInverse ::</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>fromLocallyNamelessLeftInverse e <span class="ot">=</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>  (fromLocallyNameless <span class="op">.</span> toLocallyNameless) e <span class="op">===</span> e</span></code></pre></div>
<p>Thankfully, this does indeed work as expected:</p>
<pre class="shell"><code>Tests
  Property Tests
    fromLocallyNameless ∘ toLocallyNameless == id: OK (0.35s)
      +++ OK, passed 1000 tests.</code></pre>
<p>Now that we have terms in locally nameless representation, we can perform substitution in a fairly straightforward manner. In the McBride–McKinna (MM) paper, they refer to this operation as <strong>“instantiate”</strong>. It is also common in the locally nameless literature to call the operation <strong>“opening”</strong> or <strong>“open”</strong> because it involves opening the body of a term to substitute for its outermost bound variable. As this accords with our intuitions on the meaning of substitution of locally nameless terms, we will follow this convention.</p>
<p>Note that in the code below, we follow (at least in spirit) the MM approach of using a scope type to denote a term that is only legal as the body of an expression (i.e. a term which may have bound variables referring to a non-existant outer binder such as <span class="math inline">\(\lambda \sp . \sp 1\)</span>). In our case, we only use a type synonym; however, in a more substantial implementation, one should use a newtype to get the type safety that such a measure confers.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Scope</span> f x <span class="ot">=</span> f x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>                    <span class="co">-- ┌─── term we are substituting</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>                    <span class="co">-- │</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>                    <span class="co">-- │                 ┌─── body we are substituting into</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>                    <span class="co">-- │                 │</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>                    <span class="co">-- │                 │</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="ot">open ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Scope</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>open image <span class="ot">=</span> go <span class="dv">0</span> <span class="co">-- the bound variable begins at 0</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>    go outer <span class="ot">=</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>      \<span class="kw">case</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>        <span class="dt">Var</span> fbv <span class="ot">-&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>          <span class="kw">case</span> fbv <span class="kw">of</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>         <span class="co">-- if the bound variable refers to the outer binder of the body</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>         <span class="co">-- of the term then we substitute the image.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>            <span class="dt">B</span> bv <span class="op">|</span> bv <span class="op">==</span> outer <span class="ot">-&gt;</span> image</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>                 <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">B</span> bv)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>            <span class="dt">F</span> fv <span class="ot">-&gt;</span> <span class="dt">Var</span> (<span class="dt">F</span> fv)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>        <span class="dt">App</span> l r <span class="ot">-&gt;</span> <span class="dt">App</span> (go outer l) (go outer r)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>                <span class="co">-- Note that as we have gone under another binder we must</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>                <span class="co">-- in turn bump the binding variable we substitute for</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>                <span class="co">-- so that it still refers to the outermost binder.</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>        <span class="dt">Lam</span> n b <span class="ot">-&gt;</span> <span class="dt">Lam</span> n (go (outer <span class="op">+</span> <span class="dv">1</span>) b)</span></code></pre></div>
<p>From here it is easy for us to implement reduction to both normal form and weak-head normal form (where we use call-by-name semantics). We will, in both cases, write a function that does all of the work using locally nameless terms and functions that make use of that work on named lambda terms via the previously defined conversion functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">whnfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>whnfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>              <span class="co">-- ┌─── current leftmost lambda term</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>              <span class="co">-- │</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>              <span class="co">-- │             ┌─── list of collected arguments</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>              <span class="co">-- │             │</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>              <span class="co">-- │             │</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>          <span class="co">-- if we encounter an application then we collect the</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>          <span class="co">-- argument on the right and recurse into the left term</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>     <span class="co">-- We only perform substitution if we have both</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>     <span class="co">-- a non-empty list of arguments to substitute and</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>     <span class="co">-- a leftmost lambda term.</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>          <span class="co">-- Note that we substitute the body before evaluation</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>          <span class="co">-- and hence we follow call-by-name semantics.</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        _</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>          <span class="co">-- otherwise we encountered no further leftmost</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>          <span class="co">-- lambda terms and so we re-apply App to the</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>          <span class="co">-- built-up list of arguments</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t as</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a><span class="ot">whnf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>    <span class="co">-- defer the work to the locally nameless terms</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>whnf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> whnfLN <span class="op">.</span> toLocallyNameless</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a><span class="ot">nfLN ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>nfLN term <span class="ot">=</span> go term []</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a><span class="ot">    go ::</span> <span class="dt">Term</span> (<span class="dt">Var</span> a) <span class="ot">-&gt;</span> [<span class="dt">Term</span> (<span class="dt">Var</span> a)] <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="dt">Var</span> a)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a>    go t as <span class="ot">=</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>      <span class="kw">case</span> (t, as) <span class="kw">of</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a>        ((<span class="dt">App</span> l r), args)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>          <span class="co">-- the same as above we collect right arguments in a list.</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a>          <span class="ot">-&gt;</span> go l (r <span class="op">:</span> args)</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>      <span class="co">-- If we have no arguments to apply to a lambda then we</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>      <span class="co">-- recurse into the body (this is the difference between</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true"></a>      <span class="co">-- normal form and weak head normal form).</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true"></a>        ((<span class="dt">Lam</span> n body) , [])</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true"></a>          <span class="ot">-&gt;</span> (<span class="dt">Lam</span> n (nfLN body))</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true"></a>        ((<span class="dt">Lam</span> _ body) , a<span class="op">:</span>args)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true"></a>          <span class="ot">-&gt;</span> go (substitute a body) args</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true"></a>        _</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true"></a>          <span class="co">-- If we encounter no further lambdas then we reduce </span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true"></a>          <span class="co">-- each of our built-up arguments before re-applying App.</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true"></a>          <span class="ot">-&gt;</span> foldl&#39; <span class="dt">App</span> t (<span class="fu">fmap</span> nfLN as)</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true"></a></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true"></a><span class="ot">nf ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true"></a>  <span class="co">-- again we defer all the actual work to locally nameless terms.</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true"></a>nf <span class="ot">=</span> fromLocallyNameless <span class="op">.</span> nfLN <span class="op">.</span> toLocallyNameless</span></code></pre></div>
<p>Now that we have written this reduction code, we should test it. But what on? A natural choice is to consider church encodings of the natural numbers. Since all we have in the lambda calculus is a theory of functions (with no base data types), we must encode any data in the form of functions. Church numerals act as a prototypical example of such an encoding:</p>
<p><span class="math display">\[ \mathrm{zero} = \lambda \sp \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{z} \]</span> <span class="math display">\[ \mathrm{succ}\sp \mathrm{n} = \lambda \sp \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp \mathrm{s} \sp (\mathrm{n} \sp \mathrm{s} \sp \mathrm{z}) \]</span></p>
<p>The idea here is that zero takes as arguments a step function <span class="math inline">\(\mathrm{s}\)</span> and a starting value <span class="math inline">\(\mathrm{z}\)</span>, returning the starting value. A positive number n, on the other hand, takes those arguments and applies the step function to the starting value n times. Here is what this looks like using our named terms:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="co">-- [...]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="co">-- We give ourselves some handy infix syntax for apply.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">.$</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="ot">(.$) ::</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>(<span class="op">.$</span>) <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">-- |</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">-- The unary natural numbers.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="co">-- Notice here in the inductive case we reduce to normal form. </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span class="co">-- Not doing so leads to a subtly different term wherein we </span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="co">-- are applying &quot;S&quot; to a term that itself is a lambda term</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a><span class="co">-- applied to two arguments but not yet β-reduced.</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="ot">fromNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>fromNat <span class="dt">Z</span>     <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> <span class="st">&quot;Z&quot;</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>fromNat (<span class="dt">S</span> n) <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;S&quot;</span> <span class="op">.$</span> (nf <span class="op">$</span> fromNat n <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a><span class="co">-- Let us also give ourselves names for the first </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="co">-- few church numerals for convenience:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>cZero  <span class="ot">=</span> fromNat <span class="dt">Z</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>cOne   <span class="ot">=</span> fromNat (<span class="dt">S</span> <span class="dt">Z</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>cTwo   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>cThree <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>cFour  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a>cFive  <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))))</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a>cSix   <span class="ot">=</span> fromNat (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))))</span></code></pre></div>
<p>Now recall that we wish to test how our code <em>evaluates</em> to normal form and thus we should consider some functions to actually run. Two such functions that come to mind are addition and multiplication. But how are these defined for Church numerals? Remember that <span class="math inline">\(\mathrm{n}\)</span> is meant to represent applying a step function <span class="math inline">\(\mathrm{n}\)</span> times to a value. If the value we apply to the step function is the result of applying a step function argument <span class="math inline">\(\mathrm{s}\)</span> to a starting value <span class="math inline">\(\mathrm{m}\)</span> times, we see that this is operationally the same as <span class="math inline">\(\mathrm{m} + \mathrm{n}\)</span>. In lambda terms:</p>
<p><span class="math display">\[ \mathrm{add} := \lambda \mathrm{n} \sp . \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp \mathrm{s} \sp (\mathrm{m} \sp  \mathrm{s} \sp \mathrm{z} )
  \]</span></p>
<p>Similarly, we can define multiplication of <span class="math inline">\(\mathrm{m}\)</span> by <span class="math inline">\(\mathrm{n}\)</span> by applying <span class="math inline">\(\mathrm{n}\)</span> to the step funtion <span class="math inline">\((\mathrm{m} \sp s)\)</span> (the <span class="math inline">\(\mathrm{m}\)</span>-fold application of <span class="math inline">\(\mathrm{s}\)</span>) and starting value <span class="math inline">\(\mathrm{z}\)</span>:</p>
<p><span class="math display">\[ \mathrm{mult}:= \lambda \mathrm{n} \sp . \sp \lambda \sp \mathrm{m} \sp . \sp
      \lambda \mathrm{s} \sp . \sp \lambda \sp \mathrm{z} \sp . \sp
      \mathrm{n} \sp (\mathrm{m} \sp \mathrm{s}) \sp z
  \]</span></p>
<p>Let us translate this into Haskell:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">churchAdd ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>churchAdd <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> ((<span class="dt">App</span> <span class="st">&quot;n&quot;</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span> <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>)))))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="ot">churchMult ::</span> <span class="dt">Term</span> <span class="dt">Text</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>churchMult <span class="ot">=</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  <span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    (<span class="dt">Lam</span> <span class="st">&quot;m&quot;</span> </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>      (<span class="dt">Lam</span> <span class="st">&quot;S&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;Z&quot;</span> (<span class="st">&quot;n&quot;</span> <span class="op">.$</span> (<span class="st">&quot;m&quot;</span> <span class="op">.$</span> <span class="st">&quot;S&quot;</span>) <span class="op">.$</span> <span class="st">&quot;Z&quot;</span>))))</span></code></pre></div>
<p>As a first check let us see that <span class="math inline">\(2 + 2 \rightsquigarrow 4\)</span> and that <span class="math inline">\(2 * 3 \rightsquigarrow 6\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span>      <span class="kw">as</span> <span class="dt">HU</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">-- [...]</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="ot">unitTests ::</span> <span class="dt">TestTree</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>unitTests <span class="ot">=</span> testGroup <span class="st">&quot;Church Arithmetic Unit Tests&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  [ HU.testCase</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>      <span class="st">&quot;2 + 2 ⇝ 4&quot;</span> <span class="op">$</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>      (nf <span class="op">$</span> (churchAdd <span class="op">.$</span> cTwo) <span class="op">.$</span> cTwo) <span class="op">@?=</span> cFour</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  , HU.testCase</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>      <span class="st">&quot;2 * 3 ⇝ 6&quot;</span> <span class="op">$</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>      (nf <span class="op">$</span> churchMult <span class="op">.$</span> cTwo <span class="op">.$</span> cThree) <span class="op">@?=</span> cSix</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>This is fortunately the case:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ex">Church</span> Arithmetic Unit Tests</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="ex">2</span> + 2 ⇝ 4:                         OK</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="ex">2</span> * 3 ⇝ 6:                         OK</span></code></pre></div>
<p>For a slightly more robust test, we can also write property tests to check that addition and multiplication are each commutative. First we will want to have an arbitrary instance for our definition of the unary natural numbers:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">fromInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="fu">fromInt</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="fu">fromInt</span> n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInt</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a><span class="co">-- We convert from a randomly generated integer</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a><span class="co">-- between 0 and 50.</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    arbitrary <span class="ot">=</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>      <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>        i <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">50</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>        <span class="fu">pure</span> <span class="op">$</span> <span class="fu">fromInt</span> i</span></code></pre></div>
<p>Now we can write our properties as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="co">{-</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="co">[...]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="co">-}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="ot">additionIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>additionIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>      nf (churchAdd <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>  <span class="op">===</span> nf (churchAdd <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="ot">multiplicationIsCommutative ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>multiplicationIsCommutative n m <span class="ot">=</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>      nf (churchMult <span class="op">.$</span> fromNat n <span class="op">.$</span> fromNat m)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>  <span class="op">===</span> nf (churchMult <span class="op">.$</span> fromNat m <span class="op">.$</span> fromNat n)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="ot">churchProperties ::</span> [<span class="dt">TestTree</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>churchProperties <span class="ot">=</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>  [ QC.testProperty</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>      <span class="st">&quot;Addition of Church numerals is commutative&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>     (withMaxSuccess <span class="dv">100</span> additionIsCommutative)</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>  , QC.testProperty</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>      <span class="st">&quot;Multiplication of Church numerals is commutative&quot;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>     (withMaxSuccess <span class="dv">100</span> multiplicationIsCommutative)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Running this gives us the following:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>    <span class="ex">Addition</span> of Church numerals is commutative:       OK (0.05s)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="ex">Multiplication</span> of Church numerals is commutative: OK (0.07s)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>It looks like our implementation might be (close to) working as hoped! Phew.</p>
<p>We should note that one downside to our version of locally nameless terms is that there are syntacticaly valid terms in our grammar which, nevertheless, do not make sense as lambda terms. For example, the following term is perfectly valid in our grammar: <span class="math display">\[
    \lambda \sp . \sp \lambda \sp . \sp (1 \sp 3)
  \]</span></p>
<p>Here there is a bound variable <span class="math inline">\(3\)</span> but the binding depth is only 1 (counting from <span class="math inline">\(0\)</span>). We would like, instead, to use the type system to enforce that each of our terms is (intrinsically) a valid lambda term. Doing this in Haskell is quite a challenge as such an endeavour necessarily involves types which keep track of the maximum current binding variable, and thus dependent types. In our next post we will see how to do this in Agda and then prove various properties of our locally nameless terms.</p>
<p>Thank you for reading! Feel free to contact me <a href="mailto:callan.mcgill@gmail.com">here</a> with questions, thoughts, ideas, or all of the above.</p>

        <br>
        <br>

        <!--Share buttons-->

        </div>
</article>

</div>

<footer>
    Built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<link href='https://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<script src="/js/main.js"></script>
</body>
</html>
